{"meta":{"title":"wjs的记事本","subtitle":"","description":"偶尔更新，记录工作生活","author":"Jason Wang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"为什么选择容器技术，又为什么选择了kubernetes？","slug":"为什么选择容器技术，又为什么选择了kubernetes？","date":"2018-01-26T08:44:33.000Z","updated":"2017-01-26T08:37:37.860Z","comments":true,"path":"2018/01/26/为什么选择容器技术，又为什么选择了kubernetes？/","link":"","permalink":"http://yoursite.com/2018/01/26/为什么选择容器技术，又为什么选择了kubernetes？/","excerpt":"","text":"做了一年多的‘基于K8S的PaaS云管理平台’，最近决定沉下心来，打算写以平台开发者的角度，从调研、设计、开发、测试、上线等一系列阶段经历的一些关键事件这个角度，记录下这个阶段我对于kubernetes云管平台的一些理解。 第一篇：为什么选择容器技术，又为什么选择了kubernetes? 1.为什么选择docker1.1 Docker 容器的启动可以在秒级实现，比传统的虚拟机方式要快得多。 1.2 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。 1.3 更快速的交付和部署：一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 1.4 更轻松的迁移和扩展Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。 1.5 更简单的管理使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。 2.为什么选择kubernetes容器本身并不具备调度编排功能，对于大型应用，很可能需要不止一个应用实例，而是需要集群部署，这个时候，就需要用到容器集群管理技术了。 当前主流的容器集群管理技术，包括了 Docker 官方的 Docker Swarm、Twitter 背书的 Mesos 和 Google 背书的 Kubernetes。由于Apache Mesos 只是一个分布式内核，目前的发展方向是数据中心操作系统（DCOS），它同时支持 Marathon、Kubernetes 和 Swarm 等多种框架，连 Mesosphere 也是 Kubernetes 生态的一员，从编排的角度，讨论 Mesos 意义不大，故而只对比 Docker Swarm 和 Kubernetes。 上一张对比图（来自网易） 可以看到，起码就目前而言，Swarm在各个方面都明显弱于K8S。首先，K8S社区活跃度要明显高于Swarm，甚至不在一个量级，社区活跃并不是说当遇到问题是仰仗社区解决问题，而是说明有更多厂商企业使用，有更多的最佳实践经验可以借鉴。 其次，核心功能上Swarm也还缺少很多，虽然swarm肯定会后续不断完善，但那显然需要时间的检验。 而swarm唯一的优势或许是集成在了Docker中，自然有利于开发者获得集群的能力，却也颠覆了系统级程序专注、松耦合的理念，新架构在生产环境中的稳定可靠，可能还需要更多的说服力。 而且google等厂商在之后推出了RunC标准，在CaaS中对容器进行抽象，用谁的容器都可以。容器运行时不再用Docker，而直接采用RunC，容器扩展功能通过插件来实现，基本就是全抛弃Docker了。目前RunC是三大容器厂商共同支持的标准：CoreOS Rocket, Cloud Foundry Garden和Docker容器。 所以在2016底容器白嫩派根据之争后，Kubernetes成了明显的获胜者 总结以上都是确定好要上云之后的技术选型问题。对企业来说，使用什么技术不重要，技术说到底都是工具，而它真正的价值在于帮助企业削减成本、提高效率、降低风险等，这大概是‘为什么选择XXX？’的根本答案吧。 参考http://tech.china.com/article/20161213/201612139121.htmlhttp://www.weixinnu.com/tag/article/2817098942https://blog.c.163.com/2016/11/735/https://mp.weixin.qq.com/s?__biz=MjM5MzM3NjM4MA==&amp;mid=2654687982&amp;idx=1&amp;sn=fc5c4daaf08406d8a2d091cc5ec3a393&amp;chksm=bd5803fd8a2f8aeb89d54096b38caf86c824e6d5804f455fb70e8e0890af00f60b532c55f683&amp;mpshare=1&amp;scene=1&amp;srcid=0125MnUhF76yIRRIrdMXPNEV&amp;pass_ticket=57G0whx1LppaXIfwxFImxu7tCuuQBOcdYfJ1eijXovg53c4%2BmyjV0785n0uyeXzy#rd","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://yoursite.com/tags/kubernetes/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"第一个三年","slug":"第一个三年","date":"2017-09-07T12:55:33.000Z","updated":"2017-09-07T12:55:23.520Z","comments":true,"path":"2017/09/07/第一个三年/","link":"","permalink":"http://yoursite.com/2017/09/07/第一个三年/","excerpt":"","text":"前两天惹你生气了，事情起源于一件小事，一直想对你说点什么，又正好结婚一周年，于是有了这篇文章，纪念我们第一个三年。 故事开始于2015年初的某一天，你初来公司。我还是个菜鸟， 应该是一个下午我在敲代码，你走过来问我们部门年会的事，那应该是我们第一次说话虽然没说几句话，但我知道了我们公司有个新来的小妹子，长得可爱是我喜欢的类型，应该就是所谓的眼缘吧，我们的世界有了第一个交集 第二次是我们相约打球时同坐一车，第一次知道了彼此的名字，知道了你的大学在天津，好像就这么多了，一见定情的桥段没有在我们身上发生，可能彼此印象还不错如果仅仅到这，那我们只是生命中的一个过客，然而人生有时候就是这么奇妙 2015年3月底的公司组织的日本之行，真正改变了我们关系走向，我们的剧本开始上演陌生的国家，美丽的景色，年轻的心确实是诞生爱情的绝佳环境我们聊的渐渐多了起来，那晚异国街头，可能是我们第一次，能感受到对方的流露出的情愫那真的是美好的几天，回忆无数遍也不为过 回国以后我们关系可以算突飞猛进约晚饭约烧烤约宜家 然后便有了世博的第一次牵手，酒吧的第一次接吻， 一切来的那么势不可挡，却又好像，理所应当？就好像你问我为什么喜欢你，爱情来了，需要理由吗 再然后，我们纠结了几个月，并不一帆风顺，好像也是一种完美，它反而让我们更了解彼此的心意，知道困难重重仍坚持到终点，那才是爱情的力量吧。 最终你搬来和我同住，我们从御桥搬到北蔡，从北蔡又搬到祝桥，生活似乎越来越美好了呢，期间我们去了西塘，一起逛遍了各种展览，去看了F1，去了福州，去了海边去了临安泡温泉看雪，去了崇明看日落，去了苏州诚品，去太湖边骑行，你说太湖真的很美， 然后我们有了小白，我们第一辆车，它拓宽了我们的世界， 对了，我们还拥有了一只拉布拉多，虽然它没能陪我们多久 然后便是小螃蟹迫不及待的到来了，有点猝不及防，然而却意义非凡，让我们好像一夜之间长大了一样，所有的事情都是边走边学。 于是你和我回无锡，我和你回版纳，得到长辈的祝福，我们匆匆进入人生的下个阶段 2016.9.7我们结婚啦我们去了欧洲度蜜月阿姆斯特丹巴黎卢塞恩罗马塞纳河卢浮宫翡冷翠还有太多太多下次一定会再来 2017.1.10小螃蟹顺利降生啦，从最开始换尿布都手足无措，到后来洗澡也驾轻就熟，你真的很厉害妥善的准备让一切都没这么难他三个多月时，我们还带他回了你家，我们带他看了大理的风花雪月，感受了玉龙雪山的壮美，还感受了泸沽湖的世外桃源，当然还有西双版纳，幸运的孩子，外婆家这么美而后我们带他去香港买好了保险，不管怎么样，儿子的未来一定是幸福的 这是我们的故事，刚刚开始的故事。很多人对我们结婚生子的速度感到惊讶，我知道很多人也许还略带怀疑的态度但我想说，年轻的爱情或许不成熟，但它真实，生活是自己在过，想到每一天能看到你和儿子的笑脸，想到能和你们一起去感受这个世界的美好，我就有源源不断的动力，去对抗一切，去击败一切 回到写这篇的直接原因：自省从结婚到生孩子这段时间以来，我一直算不上太上心，时而会与你有争吵。有时候我觉得你不能理解我，其实是我没能理解你罢了因为你做的太好了，我还没跟上你的脚步。以前我一直没有好好正视自己，幸而现在还有机会，对于信任，对于责任、对于理解对于爱的方式，你让我更加懂得一段感情要怎样变得更好，或许下个三年，三十年我们都能带着儿子，带着家人，一起去感受这个世界的美好希望我们那时回首我们这第一个三年时，只会感叹，人生漫漫，幸而有你","categories":[{"name":"lovers","slug":"lovers","permalink":"http://yoursite.com/categories/lovers/"}],"tags":[{"name":"lovers","slug":"lovers","permalink":"http://yoursite.com/tags/lovers/"}]},{"title":"Java-133个面试题","slug":"Java-133个面试题","date":"2017-08-21T06:00:00.000Z","updated":"2017-08-21T06:09:59.315Z","comments":true,"path":"2017/08/21/Java-133个面试题/","link":"","permalink":"http://yoursite.com/2017/08/21/Java-133个面试题/","excerpt":"","text":"最近5年133个Java面试问题列表Java 面试随着时间的改变而改变。在过去的日子里，当你知道 String 和 StringBuilder 的区别（String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象。因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，影响性能，可以考虑使用可变字符序列StringBuilder）就能让你直接进入第二轮面试，但是现在问题变得越来越高级，面试官问的问题也更深入。 在我初入职场的时候，类似于 Vector 与 Array 的区别、HashMap 与 Hashtable 的区别是最流行的问题，只需要记住它们，就能在面试中获得更好的机会，但这种情形已经不复存在。如今，你将会被问到许多 Java 程序员都没有看过的领域，如 NIO，设计模式，成熟的单元测试，或者那些很难掌握的知识，如并发、算法、数据结构及编码。 由于我喜欢研究面试题，因此我已经收集了许多的面试问题，包括许多许多不同的主题。我已经为这众多的问题准备一段时间了，现在我将它们分享给你们。这里面不但包含经典的面试问题，如线程、集合、equals 和 hashcode、socket，而且还包含了 NIO、数组、字符串、Java 8 等主题。 该列表包含了入门级 Java 程序员和多年经验的高级开发者的问题。无论你是 1、2、3、4、5、6、7、8、9 还是 10 年经验的开发者，你都能在其中找到一些有趣的问题。这里包含了一些超级容易回答的问题，同时包含经验丰富的 Java 程序员也会棘手的问题。 当然你们也是非常幸运的，当今有许多好的书来帮助你准备 Java 面试，其中有一本我觉得特别有用和有趣的是 Markham 的 Java 程序面试揭秘（Java Programming Interview Exposed）。 这本书会告诉你一些 Java 和 JEE 面试中最重要的主题，即使你不是准备 Java 面试，也值得一读。 该问题列表特别长，我们有各个地方的问题，所以，答案必须要短小、简洁、干脆，不拖泥带水。因此，除了这一个段落，你只会听到问题与答案，再无其他内容，没有反馈，也没有评价。为此，我已经写好了一些博文，在这些文章中你可以找到我对某些问题的观点，如我为什么喜欢这个问题，这个问题的挑战是什么？期望从面试者那获取到什么样的答案？ 这个列表有一点不同，我鼓励你采用类似的方式去分享问题和答案，这样容易温习。我希望这个列表对面试官和候选人都有很好的用处，面试官可以对这些问题上做一些改变以获取新奇和令人惊奇的元素，这对一次好的面试来说非常重要。而候选者，可以扩展和测试 Java 程序语言和平台关键领域的知识。2015 年，会更多的关注并发概念，JVM 内部，32 位 JVM 和 64 JVM的区别，单元测试及整洁的代码。我确信，如果你读过这个庞大的 Java 面试问题列表，无论是电话面试还是面对面的面试，你都能有很好的表现。 Java 面试中的重要话题除了你看到的惊人的问题数量，我也尽量保证质量。我不止一次分享各个重要主题中的问题，也确保包含所谓的高级话题，这些话题很多程序员不喜欢准备或者直接放弃，因为他们的工作不会涉及到这些。Java NIO 和 JVM 底层就是最好的例子。你也可以将设计模式划分到这一类中，但是越来越多有经验的程序员了解 GOF 设计模式并应用这些模式。我也尽量在这个列表中包含 2015 年最新的面试问题，这些问题可能是来年关注的核心。为了给你一个大致的了解,下面列出这份 Java 面试问题列表包含的主题： 多线程，并发及线程基础 数据类型转换的基本原则 垃圾回收（GC） Java 集合框架 数组 字符串 GOF 设计模式 SOLID （单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）设计原则 抽象类与接口 Java 基础，如 equals 和 hashcode 泛型与枚举 Java IO 与 NIO 常用网络协议 Java 中的数据结构和算法 正则表达式 JVM 底层 Java 最佳实践 JDBC Date, Time 与 Calendar Java 处理 XML JUnit 编程 120 大 Java 面试题及答案现在是时候给你展示我近 5 年从各种面试中收集来的 120 个问题了。我确定你在自己的面试中见过很多这些问题，很多问题你也能正确回答。 多线程、并发及线程的基础问题 1）Java 中能创建 volatile 数组吗？ 能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。 2）volatile 能使得一个非原子操作变成原子操作吗？ 一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。 3）volatile 修饰符的有过什么实践？ 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 4）volatile 类型变量提供什么保证？ volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。 5) 10 个线程和 2 个线程的同步代码，哪个更容易写？ 从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。 6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？ wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码： 1234567// The standard idiom for using the wait methodsynchronized (obj) &#123;while (condition does not hold)obj.wait(); // (Releases lock, and reacquires on wakeup)... // Perform action appropriate to condition&#125; 参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。 7）什么是多线程环境下的伪共享（false sharing）？ 伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示： 伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。 有经验程序员的 Java 面试题8）什么是 Busy spin？我们为什么要使用它？ Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。 9）Java 中怎么获取一份线程 dump 文件？ 在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。 10）Swing 是线程安全的？ 不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。 11）什么是线程局部变量？ 当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类) 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。 ThreadLocal是如何为每个线程创建变量的副本的： 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 总结： a.实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的 b.为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal； c.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法 12）用 wait-notify 写一段代码来解决生产者-消费者问题？ 请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。 13) 用 Java 写一个线程安全的单例模式（Singleton）？ 请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。 14）Java 中 sleep 方法和 wait 方法的区别？ 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。 15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？ 不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。 16）我们能创建一个包含可变对象的不可变对象吗？ 是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。 数据类型和 Java 基础面试问题 17）Java 中应该使用什么数据类型来代表价格？ 如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。 18）怎么将 byte 转换为 String？ 可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。 19）Java 中怎样将 bytes 转换为 long 类型？ String接收bytes的构造器转成String，再Long.parseLong 20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？ 是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。 21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B； 可以，向下转型。但是不建议使用，容易出现类型转型异常. 22）哪个类包含 clone 方法？是 Cloneable 还是 Object？ java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。 23）Java 中 ++ 操作符是线程安全的吗？ 不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。 24）a = a + b 与 a += b 的区别 += 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。 12345byte a = 127;byte b = 127;b = a + b; // error : cannot convert from int to byteb += a; // ok （因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错） 25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？ 不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。 26）3*0.1 == 0.3 将会返回什么？true 还是 false？ false，因为有些浮点数不能完全精确的表示出来。 27）int 和 Integer 哪个会占用更多的内存？ Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。 28）为什么 Java 中的 String 是不可变的（Immutable）？ Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。 29）我们能在 Switch 中使用 String 吗？ 从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。 30）Java 中的构造器链是什么？ 当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。 JVM 底层 与 GC（Garbage Collection） 的面试问题31）64 位 JVM 中，int 的长度是多数？ Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。 32）Serial 与 Parallel GC之间的不同之处？ Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。 33）32 位和 64 位的 JVM，int 类型变量的长度是多数？ 32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。 34）Java 中 WeakReference 与 SoftReference的区别？ Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。 StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收 WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, 将被GC回收 虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用 35）WeakHashMap 是怎么工作的？ WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。 36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？ 当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。 37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？ 你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。 38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？ 理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。 39）JRE、JDK、JVM 及 JIT 之间有什么不同？ JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 3 年工作经验的 Java 面试题40）解释 Java 堆空间及 GC？ 当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。 JVM 底层面试题及答案41）你能保证 GC 执行吗？ 不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。 42）怎么获取 Java 程序使用的内存？堆使用的百分比？ 可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。 43）Java 中堆和栈有什么区别？ JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。Difference between stack and heap memory in Java 关于内存的的面试问题和答案Java 基本概念面试题 44）“a==b”和”a.equals(b)”有什么区别？ 如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。 45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？ hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。 46）final、finalize 和 finally 的不同之处？ final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 47）Java 中的编译期常量是什么？使用它又什么风险？ 公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 Java 集合框架的面试题这部分也包含数据结构、算法及数组的面试问题 48) List、Set、Map 和 Queue 之间的区别(答案) List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。 49）poll() 方法和 remove() 方法的区别？ poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？(答案) PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。 51）ArrayList 与 LinkedList 的不区别？(答案) 最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。 52）用哪两种方式来实现集合的排序？(答案) 你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。 53）Java 中怎么打印数组？(answer答案) 你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。 54）Java 中的 LinkedList 是单向链表还是双向链表？(答案) 是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。 55）Java 中的 TreeMap 是采用什么树实现的？(答案) Java 中的 TreeMap 是使用红黑树实现的。 56) Hashtable 与 HashMap 有什么不同之处？(答案) 这两个类有许多不同的地方，下面列出了一部分：a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。更多的不同之处参见答案。 57）Java 中的 HashSet，内部是如何工作的？(answer答案) HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。 58）写一段代码在遍历 ArrayList 时移除一个元素？(答案) 该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。 59）我们能自己写一个容器类，然后使用 for-each 循环吗？ 可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。 60）ArrayList 和 HashMap 的默认大小是多数？(答案) 在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段： 12345// from ArrayList.java JDK 1.7private static final int DEFAULT_CAPACITY = 10; //from HashMap.java JDK 7static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 61）有没有可能两个不相等的对象有有相同的 hashcode？ 有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。 62）两个相同的对象会有不同的的 hash code 吗？ 不能，根据 hash code 的规定，这是不可能的。 63）我们可以在 hashcode() 中使用随机数字吗？(答案) 不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。 64）Java 中，Comparator 与 Comparable 有什么不同？(答案) Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。 65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案) 因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。 Java IO 和 NIO 的面试题IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。 66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？ 67）Java 中怎么创建 ByteBuffer？ 68）Java 中，怎么读写 ByteBuffer ？ 69）Java 采用的是大端还是小端？ 70）ByteBuffer 中的字节序是什么？ 71）Java 中，直接缓冲区与非直接缓冲器有什么区别？(答案) 72）Java 中的内存映射缓存区是什么？(answer答案) 73）socket 选项 TCP NO DELAY 是指什么？ 74）TCP 协议与 UDP 协议有什么区别？(answer答案) 75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案) Java 最佳实践的面试问题包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。 76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？(答案) 这是我在写Java 并发程序的时候遵循的一些最佳实践：a）给线程命名，这样可以帮助调试。b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。c）如果可以，更偏向于使用 volatile 而不是 synchronized。d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。 77）说出几点 Java 中使用 Collections 的最佳实践(答案) 这是我在使用 Java 中 Collectionc 类的一些最佳实践：a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。d）使用迭代器来循环集合。e）使用集合的时候使用泛型。 78）说出至少 5 点在 Java 中使用线程的最佳实践。(答案) 这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：a）对线程命名b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。c）使用线程池 79）说出 5 条 IO 的最佳实践(答案) IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。b）使用 NIO 和 NIO2c）在 finally 块中关闭流，或者使用 try-with-resource（Java7） 语句。d）使用内存映射文件获取更快的 IO。 80）列出 5 个应该遵循的 JDBC 最佳实践(答案) 有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：a）使用批量的操作来插入和更新数据b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。c）使用数据库连接池d）通过列名来获取结果集，不要使用列的下标来获取。 81）说出几条 Java 中方法重载的最佳实践？(答案) 下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。b）不要重载参数数量一致，而只是参数顺序不同的方法。c）如果重载的方法参数个数多于 5 个，采用可变参数。 Date、Time 及 Calendar 的面试题82）在多线程环境下，SimpleDateFormat 是线程安全的吗？(答案) 不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。 83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？(答案) Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。 84）Java 中，怎么在格式化的日期中显示时区？ pattern中加z yyyy-MM-dd HH:mm:ss.SSS Z 85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？ java.sql.Date是针对SQL语句使用的，它只包含日期而没有时间部分,它们都有getTime方法返回毫秒数，自然就可以直接构建。java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。 86）Java 中，如何计算两个日期之间的差距？ 12345678public static int dateDiff(Date d1, Date d2) throws Exception &#123;long n1 = d1.getTime();long n2 = d2.getTime();long diff = Math.abs(n1 - n2);diff /= 3600 * 1000 * 24;return diff;&#125; 87）Java 中，如何将字符串 YYYYMMDD 转换为日期？ SimpleDateFormat的parse方法 单元测试 JUnit 面试题89）如何测试静态方法？(答案) 可以使用 PowerMock 库来测试静态方法。 90）怎么利用 JUnit 来测试一个方法的异常？(答案) 91）你使用过哪个单元测试库来测试你的 Java 程序？(答案) 92）@Before 和 @BeforeClass 有什么区别？(答案) 编程和代码相关的面试题93）怎么检查一个字符串只包含数字？(解决方案) 94）Java 中如何利用泛型写一个 LRU 缓存？(答案) 95）写一段 Java 程序将 byte 转换为 long？(答案) 95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？(解决方案) 97）Java 中，怎么获取一个文件中单词出现的最高频率？(解决方案) 98）如何检查出两个给定的字符串是反序的？(解决方案) 99）Java 中，怎么打印出一个字符串的所有排列？(解决方案) 100）Java 中，怎样才能打印出数组中的重复元素？(解决方案) 101）Java 中如何将字符串转换为整数？(解决方案) 102）在没有使用临时变量的情况如何交换两个整数变量的值？(解决方案) 关于 OOP 和设计模式的面试题这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。 103）接口是什么？为什么要使用接口而不是直接使用具体类？ 接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。 104）Java 中，抽象类与接口之间有什么不同？(答案) Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。 105）除了单例模式，你在生产环境中还用过什么设计模式？ 这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。 106）你能解释一下里氏替换原则吗?(答案) 107) 什么情况下会违反迪米特法则？为什么会有这个问题？(答案) 迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。 108）适配器模式是什么？什么时候使用？ 适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。 109）什么是“依赖注入”和“控制反转”？为什么有人使用？(答案) 110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？(答案) 111）构造器注入和 setter 依赖注入，那种方式更好？(答案) 每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。 112）依赖注入和工厂模式之间有什么不同？(答案) 虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。 113）适配器模式和装饰器模式有什么区别？(答案) 虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。 114）适配器模式和代理模式之前有什么不同？(答案) 这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。 115）什么是模板方法模式？(答案) 模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。 116）什么时候使用访问者模式？(答案) 访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。 117）什么时候使用组合模式？(答案) 组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。 118）继承和组合之间有什么不同？(答案) 虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。 119）描述 Java 中的重载和重写？(答案) 重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。 120）Java 中，嵌套公共静态类与顶级类有什么不同？(答案) 类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。 121) OOP 中的 组合、聚合和关联有什么区别？(答案) 如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 122）给我一个符合开闭原则的设计模式的例子？(答案) 开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。 123）抽象工厂模式和原型模式之间的区别？(答案) 124）什么时候使用享元模式？(答案) 享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。 Java 面试中其他各式各样的问题这部分包含 Java 中关于 XML 的面试题，JDBC 面试题，正则表达式面试题，Java 错误和异常及序列化面试题 125）嵌套静态类与顶级类有什么区别？(答案) 一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。 126）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？(解决方案) 一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。 127）Java 中，受检查异常 和 不受检查异常的区别？(答案) 受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。 128）Java 中，throw 和 throws 有什么区别？(答案) throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″)而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。 129）Java 中，Serializable 与 Externalizable 的区别？(答案) Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。 130）Java 中，DOM 和 SAX 解析器有什么不同？(答案) DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。 131）说出 JDK 1.7 中的三个新特性？(答案) 虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。 132）说出 5 个 JDK 1.8 引入的新特性？(答案) Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：Lambda 表达式，允许像对象一样传递匿名函数Stream API，充分利用现代多核 CPU，可以写出很简洁的代码Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用扩展方法，现在，接口中可以有静态、默认方法。重复注解，现在你可以将相同的注解在同一类型上使用多次。 133）Java 中，Maven 和 ANT 有什么区别？(答案) 虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。 这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。 Java EE 相关的面试题为了做 Java EE 的朋友，这里列出了一些 web 开发的特定问题，你们可以用来准备 JEE 部分的面试： 10 大 Spring 框架面试题及答案(参见) 10 个非常好的 XML 面试问题（Java 程序员）(参见) 20 个非常好的设计模式面试问题(参见) 10个最流行的 Struts 面试题（Java 开发者）(参见) 20 个 Tibco Rendezvous 及 EMS 的面试题(更多) 10 个最频繁被问到的 Servlet 面试问题及答案(参见) 20 个 jQuery 面试问题（Java Web 开发者）(列表) 10 个非常好的 Oracle 面试问题（Java 开发者）(参见) 10 大 来自 J2EE 面试中的 JSP 问题(更多) 12 个很好的 RESTful Web Services 面试问题(参见) 10 大 EJB 面试问题及答案(参见) 10 大 JMS 及 MQ 系列面试题及答案(列表) 10 个非常好 Hibernate 面试问题（Java EE 开发者）(参见) 10 个非常好的 JDBC 面试题（Java 开发者）(参见) 15 个 Java NIO 和网络面试题及答案(参见) 10 大 XSLT 面试题及答案(更多) 15 个来自 Java 面试的数据结构和算法问题(参见) 10 大 Java 面试难题及答案(参见) 40 个核心 Java 移动开发面试题及答案(列表) 推荐给 Java 面试者的书籍如果你正为 Java 面试寻找好的准备，你可以看一下下面的书籍，这些书籍包含了理论及编码的相关问题 Markham 的 Java 编程面试揭秘(参见) 破解编码面试：150 个编程问题及解答(参见) 程序面试揭秘：寻找下一份工作的秘密(参见)","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"每天一小时java计划01 - volatile","slug":"每天一小时java计划01 - volatile","date":"2017-08-21T00:00:00.000Z","updated":"2017-08-21T05:37:46.751Z","comments":true,"path":"2017/08/21/每天一小时java计划01 - volatile/","link":"","permalink":"http://yoursite.com/2017/08/21/每天一小时java计划01 - volatile/","excerpt":"","text":"原文链接：http://www.cnblogs.com/dolphin0520/p/3920373.html volatile的作用是，所修饰的field如果变化，则所有的读操作都能够看到，这个field直接就刷新到主存中了，就像同步一样，而且读取操作本身就在主存，非volatile修饰的field上的操作不会刷新到主存。以上的操作都是原子操作，而++这种操作是每次都要依赖于上一次的值，根本不是原子操作，换句话说，volatile要正常工作，至少所修饰的field不能依赖其他值，而volatile还没强大到影响操作原子性的地步，所以这论证意义不大。最后，如果安全要求高，首要选择就是synchronized 1.volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。先看一段代码，假如线程1先执行，线程2后执行：12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。但是用volatile修饰之后就变得不一样了：第一：使用volatile关键字会强制将修改的值立即写入主存；第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。那么线程1读取到的就是最新的正确的值。 2.volatile保证原子性吗？从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？下面看一个例子：1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。那么两个线程分别进行了一次自增操作后，inc只增加了1。解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。把上面的代码改成以下任何一种都可以达到效果：采用synchronized：1234567891011121314151617181920212223public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock：1234567891011121314151617181920212223242526272829public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用AtomicInteger：1234567891011121314151617181920212223public class Test &#123; public AtomicInteger inc = new AtomicInteger(); public void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile能保证有序性吗？在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。volatile关键字禁止指令重排序有两层意思：1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。可能上面说的比较绕，举个简单的例子：12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。那么我们回到前面举的一个例子：123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 4.volatile的原理和实现机制前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。下面这段话摘自《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；2）它会强制将对缓存的修改操作立即写入主存；3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 5.使用volatile关键字的场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：1）对变量的写操作不依赖于当前值2）该变量没有包含在具有其他变量的不变式中实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。下面列举几个Java中使用volatile的几个场景。1.状态标记量1234567891011121314151617181920volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125;volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); 2.double check1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 至于为何需要这么写请参考：《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024和http://www.iteye.com/topic/652440","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"kubernetes和Swarm，你站哪一队？","slug":"kubernetes和Swarm，你站哪一队？","date":"2017-08-18T07:44:33.000Z","updated":"2017-08-18T08:44:10.780Z","comments":true,"path":"2017/08/18/kubernetes和Swarm，你站哪一队？/","link":"","permalink":"http://yoursite.com/2017/08/18/kubernetes和Swarm，你站哪一队？/","excerpt":"","text":"前言前几天阿里云的技术专家来我司介绍云计算相关产品，提到了关于容器编排技术的选择。由于阿里是Docker中国目前唯一代理，所以态度明确的表达大B企业应该使用dockerEE+Swarm。这也引起了我们新一轮的调研和考量（我们前期使用的是k8s）。 背景当前主流的容器集群管理技术，包括了 Docker 官方的 Docker Swarm、Twitter 背书的 Mesos 和 Google 背书的 Kubernetes。由于Apache Mesos 只是一个分布式内核，目前的发展方向是数据中心操作系统（DCOS），它同时支持 Marathon、Kubernetes 和 Swarm 等多种框架，连 Mesosphere 也是 Kubernetes 生态的一员，从编排的角度，讨论 Mesos 意义不大，故而只对比 Docker Swarm 和 Kubernetes。 我个人的立场kubernetes是更为成熟的编排工具，有google背书，社区活跃明显超过Swarm，并且考虑到目前Docker公司和整个CaaS生态圈的关系，如果非要站队，我会选择Kubernetes 分析先上一张对比图（来自网易） 可以看到，起码就目前而言，Swarm在各个方面都明显弱于K8S。首先，K8S社区活跃度要明显高于Swarm，甚至不在一个量级，社区活跃并不是说当遇到问题是仰仗社区解决问题，而是说明有更多厂商企业使用，有更多的最佳实践经验可以借鉴。 其次，核心功能上Swarm也还缺少很多，虽然swarm肯定会后续不断完善，但那显然需要时间的检验。 而swarm唯一的优势或许是集成在了Docker中，自然有利于开发者获得集群的能力，却也颠覆了系统级程序专注、松耦合的理念，新架构在生产环境中的稳定可靠，可能还需要更多的说服力。 最后，Docker本身的发展和CaaS生态圈也是摩擦重重，出现了很多的槽点，比如： Docker向后兼容性问题 Docker容器在某些生产环境运行不够稳定，在企业级方面还有待提高 越过了操作系统的界限（Docker似乎不愿使用systemd，取而代之使用Docker Daemon来提供初始化，服务激活，安全和容器日志的相关功能） 如果甚至都不用Docker呢我们很容易的想到，以Docker目前的发展态势来说，一旦docker和google等巨头闹翻，那基于k8s+docker来做的系统就没法使用了吗？ 我觉得也并不是。 首先，我们最简单的方式，或许是不升级新的docker版本，最多就是后续问题不在有docker官方支持。但我相信这么多企业在用k8s，到时候google或者其他大厂、社区必定会有相应解决方案。 而且google等厂商也已经准备了应对之策，那就是在CaaS中废弃Docker，对容器进行抽象，用谁的容器都可以。容器运行时不再用Docker，而直接采用RunC，容器扩展功能通过插件来实现，基本就是全抛弃Docker了。目前RunC是三大容器厂商共同支持的标准：CoreOS Rocket, Cloud Foundry Garden和Docker容器。 目前的形势，就形成了Docker和各个CaaS/PaaS厂商在同一层面竞争，在CaaS/PaaS平台，Docker并没有什么优势，但是Docker想把其容器的广泛使用的优势在CaaS中延续，目前看来并不容易。容器的主要用户还是个人用户、开发者用户、运维用户，而CaaS是企业系统，二者目标客户不同、技术要求不同。 随着这个生态的演进，Docker容器会更多的用于开发、测试环境，而RunC在各个CaaS厂商的推动下会在生产环境得到广泛的应用。 另外其实容器技术壁垒并不高，容器最主要的两个的技术来源：1、 Namespace—来源于IBM2、 cGroup—-来源于Google其他的容器核心技术都是Linux操作系统的功能，容器的核心技术是和Linux操作系统密切相关的，Docker本身在容器核心并没有什么贡。所以容器生态圈的公司撇开Docker做一个容器标准不是难事。 作为用户或是容器生态圈的创业公司，不能一棵树上吊死，如果在容器层面只考虑Docker，而不考虑RunC，可能会和CaaS/PaaS生态圈的标准越来越远，未来和CaaS/PaaS的标准容器差异越来越大，主流的CaaS/PaaS厂商和技术，如K8s/Mesos/Cloud Foundry均不再支持Docker容器超越RunC之外的功能，而只支持插件对RunC功能的扩展。 业界更普遍的定位是Docker用于开发测试环境，而RunC用于生产环境，所以对于要在生产环境采用容器技术的，一定要研究RunC。 总结对于企业来说，目前使用Kubernetes+Docker或许是最好的选择，而未来的方向应该是转向Kubenetes+RunC。而到时候转换的成本其实也不用担心，其实现在已经有Docker镜像转为RunC镜像的方式了（Riddler） 参考http://tech.china.com/article/20161213/201612139121.htmlhttp://www.weixinnu.com/tag/article/2817098942https://blog.c.163.com/2016/11/735/","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://yoursite.com/tags/kubernetes/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java实现kubernates API的访问调用","slug":"java实现kubernates-API的访问调用","date":"2017-08-07T01:44:33.000Z","updated":"2017-08-09T02:12:47.685Z","comments":true,"path":"2017/08/07/java实现kubernates-API的访问调用/","link":"","permalink":"http://yoursite.com/2017/08/07/java实现kubernates-API的访问调用/","excerpt":"","text":"1. 前言kubernetes及各开源社区为开发人员提供了各种语言版的Client Library，让我们可以通过编程的方式可以实现调用Kubernetes API，从而完成pod、service、RC等资源的图形化创建和管理。本篇主要介绍使用java语言的实现 2. 使用场景开发基于kubernetes的容器云管理平台 3. 基于的框架用java语言开发的有两种，一个是基于Jersey的，一个是基于Fabric8。 -Jersey是一个方便简化开发RESRFul Web Service的框架，契合kubernetesAPI的设计，所以采用jersey会比较省力，但还是需要开发者自己做很多工作。 -Fabric8中的kubernates-client.xx.jar，kubernates-model.xx.jar等工具包包对kubernates api做了很好的封装，访问代码比较简单。 本篇将选择fabric8实现 4. 使用步骤4.1 首先导入核心jar包 4.2 创建连接API-Server的client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package org.demo.framework.engine.k8s.util;import io.fabric8.kubernetes.api.model.*;import io.fabric8.kubernetes.api.model.extensions.*;import io.fabric8.kubernetes.api.model.extensions.Deployment;import io.fabric8.kubernetes.client.Config;import io.fabric8.kubernetes.client.ConfigBuilder;import io.fabric8.kubernetes.client.*;import okhttp3.TlsVersion;import org.apache.log4j.Logger;import java.io.Closeable;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Map;public class Fabric8KubeUtils implements KubeUtils&lt;KubernetesClient&gt; &#123; private KubernetesClient client; private static final int CONNECTION_TIMEOUT = 3 * 1000; private static final int REQUEST_TIMEOUT = 3 * 1000; private static Logger logger = Logger.getLogger(Fabric8KubeUtils.class); @Override public KubernetesClient getClient() &#123; return client; &#125; @Override public void setClient(KubernetesClient client) &#123; this.client = client; &#125; private Fabric8KubeUtils(KubernetesClient client) &#123; this.client = client; &#125; /**传入参数，连接k8s的api server**/ public static KubeUtils buildKubeUtils(Cluster cluster, String namespace) throws K8sDriverException &#123; if (cluster == null) &#123; throw new K8sDriverException(&quot;cluster is null&quot;); &#125; String key = cluster.md5Key(namespace); if (KUBEUTILSMAP.containsKey(key)) &#123; return KUBEUTILSMAP.get(key); &#125; String master = cluster.getApi(); master = CommonUtil.fullUrl(master); if (StringUtils.isBlank(master)) &#123; throw new K8sDriverException(&quot;master api is null, cluster id=&quot; + cluster.getId() + &quot;, cluster name=&quot; + cluster.getName()); &#125; Config config; if (master.toLowerCase().startsWith(&quot;https://&quot;)) &#123; config = new ConfigBuilder().withMasterUrl(master) .withTrustCerts(true) .withNamespace(namespace) .withOauthToken(cluster.getOauthToken()) .withUsername(cluster.getUsername()) .withPassword(cluster.getPassword()) .removeFromTlsVersions(TlsVersion.TLS_1_0) .removeFromTlsVersions(TlsVersion.TLS_1_1) .removeFromTlsVersions(TlsVersion.TLS_1_2) .withRequestTimeout(REQUEST_TIMEOUT) .withConnectionTimeout(CONNECTION_TIMEOUT) .build(); &#125; else &#123; config = new ConfigBuilder().withMasterUrl(master) .withNamespace(namespace) .withOauthToken(cluster.getOauthToken()) .withUsername(cluster.getUsername()) .withPassword(cluster.getPassword()) .removeFromTlsVersions(TlsVersion.TLS_1_0) .removeFromTlsVersions(TlsVersion.TLS_1_1) .removeFromTlsVersions(TlsVersion.TLS_1_2) .withTrustCerts(true) .withRequestTimeout(REQUEST_TIMEOUT) .withConnectionTimeout(CONNECTION_TIMEOUT) .build(); &#125; KubeUtils kubeUtils = buildKubeUtils(config); KUBEUTILSMAP.putIfAbsent(key, kubeUtils); return kubeUtils; &#125; /**创建client**/ public static KubeUtils buildKubeUtils(Config config) throws K8sDriverException &#123; KubernetesClient client; try &#123; client = new DefaultKubernetesClient(config); &#125; catch (Exception e) &#123; throw new K8sDriverException(&quot;instantialize kubernetes client error&quot;); &#125; return new Fabric8KubeUtils(client); &#125; &#125; 4.3 创建k8s的资源对象，作为参传给client操作k8s（增删改时需要）123// 可以通过k8s??Builder()来创建资源对象// 如下创建一个service对象，lb为包含service必要信息的实体类对象Service newService = new K8sServiceBuilder(lb).build(); 4.4 通过得到的client，可以对k8s的各种资源增删改查各种操作：NodesNamespacesServicesReplicationcontrollersPodsDeploymentsResourcequotas1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/**创建pod**/@Override public Pod createPod(Pod pod) throws K8sDriverException &#123; logger.debug(&quot;create pod with specify=&quot; + pod.toString()); try &#123; return client.pods().create(pod); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;/**创建service**/@Overridepublic Service createService(Service service) throws K8sDriverException &#123; logger.debug(&quot;create service=&quot; + service); if (service == null) &#123; return null; &#125; try &#123; return client.services().create(service); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125;&#125;/**创建RC**/ @Override public ReplicationController createReplicationController(ReplicationController rc) throws K8sDriverException &#123; if (rc == null) &#123; return null; &#125; logger.debug(&quot;create replication controller with rc=\\n&quot; + rc); try &#123; return client.replicationControllers().create(rc); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;/**创建deployment**/@Override public Deployment createDeployment(Deployment deployment) throws K8sDriverException &#123; if (deployment == null) &#123; return null; &#125; logger.debug(&quot;create deployment with deployment=\\n&quot; + deployment); try &#123; return client.extensions().deployments().create(deployment); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;/**按条件列出所有node**/@Override public NodeList listNode(Map&lt;String, String&gt; labelSelector) throws K8sDriverException &#123; logger.debug(&quot;list node with selector=&quot; + labelSelector); try &#123; return client.nodes().withLabels(labelSelector).list(); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"kuberbets","slug":"kuberbets","permalink":"http://yoursite.com/tags/kuberbets/"}]},{"title":"用python 分析微信好友信息并生成词云","slug":"用python 分析微信好友信息并生成词云","date":"2017-08-07T01:24:33.000Z","updated":"2017-08-07T01:50:17.806Z","comments":true,"path":"2017/08/07/用python 分析微信好友信息并生成词云/","link":"","permalink":"http://yoursite.com/2017/08/07/用python 分析微信好友信息并生成词云/","excerpt":"","text":"在知乎上偶然看到有人推荐itchart这个微信接口，抱着好奇的想法尝试了以下，果然非常好玩。官方链接：http://itchat.readthedocs.io/zh/latest/#itchat 目录结构get_info.py这个类用来爬取好友信息并保存到指定文件12345678910111213141516171819202122232425import itchatimport osimport timebasepath = os.path.dirname(os.path.realpath(__file__))download_path = basepath+&apos;\\downloads&apos;+ &apos;\\\\&apos;# 调用itchat接口登录并拉取数据itchat.login()friends = itchat.get_friends(update=True)[0:]fmt=&apos;%Y%m%d%H%M%S&apos; #定义时间显示格式Date=time.strftime(fmt,time.localtime(time.time()))download_file_name = &apos;friendslist_&apos;+friends[0][&apos;NickName&apos;]+ &apos;_&apos; + Date + &apos;.txt&apos;f = open(download_path+download_file_name,&apos;wb&apos;)print(download_path+download_file_name)for i in friends[1:]: friend = (str(i) + &quot;\\n&quot;).encode(encoding=&apos;gb18030&apos;) # print(str(i)) f.write(friend)f.close() analyse.py这个类根据下载的好友数据分析好友信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Author:Jason.wangimport reimport osimport timebase_pic = &quot;C:/Users/Think/Pictures/Saved Pictures/beb28c538ac52a91.jpg&quot;source_file = &quot;friendslist_雨佳Clara_20170724223344.txt&quot;source_file = &quot;friendslist_say_20170724132202.txt&quot;basepath = os.path.dirname(os.path.realpath(__file__))download_file = basepath+&apos;\\downloads\\\\&apos;+ source_filefs_str = &apos;&apos;with open(download_file,&apos;rb&apos;) as f: fs_str = f.read().decode(&apos;gb18030&apos;)friends = fs_str.split(&apos;\\n&apos;)# 初始化计数器 male = female = other = 0# 所有省份Provinces_list = []#friends[0]是自己的信息，所以要从friends[1]开始 for i in friends: if i.__len__()&gt;0: i = i.replace(&apos;&lt;ContactList: [&apos;,&apos;&quot;&lt;ContactList: [&apos;) i = i.replace(&apos;]&gt;&apos;,&apos;]&gt;&quot;&apos;) friend = eval(i) # 统计性别 sex = friend[&quot;Sex&quot;] if sex == 1: male += 1 exit elif sex ==2: female += 1 else: other+=1 # 统计地区 Province = friend[&quot;Province&quot;] Provinces_list.append(Province)#计算朋友总数 total = len(friends)#打印出自己的好友性别比例 print(&quot;总好友数： %d&quot; % total + &quot;\\n&quot; + &quot;男性好友： %d 个,占比 %.2f%%&quot; % (male,(float(male)/total*100)) + &quot;\\n&quot; + &quot;女性好友： %d 个,占比 %.2f%%&quot; % (female,(float(female) / total * 100)) + &quot;\\n&quot; + &quot;不明性别好友： %d 个,占比 %.2f%%&quot; % (other,(float(other) / total * 100)))Provinces_set = set(Provinces_list)Provinces_dict = &#123;&#125;for i in Provinces_set: Provinces_dict[i] = Provinces_list.count(i)# 对省份字典按value排序Provinces_dict = sorted(Provinces_dict.items(),key=lambda asd:asd[1],reverse=True)print(&quot;===============人数排名前10地区如下==================&quot;)top = 0for k,v in Provinces_dict: if top&lt;10: print(&quot;%s : %d 个，占比 ： %.2f%%&quot; % (k,v,float(v)/total*100)) top+=1 输出结果： ciyun.py根据签名生成词云123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*- coding:UTF-8 -*-# Author:Jason.wangimport reimport osimport timebase_pic = &quot;C:/Users/Think/Pictures/Saved Pictures/beb28c538ac52a91.jpg&quot;source_file = &quot;friendslist_雨佳Clara_20170724223344.txt&quot;# source_file = &quot;friendslist_say_20170724132202.txt&quot;basepath = os.path.dirname(os.path.realpath(__file__))download_file = basepath+&apos;\\downloads\\\\&apos;+ source_filefs_str = &apos;&apos;with open(download_file,&apos;rb&apos;) as f: fs_str = f.read().decode(&apos;gb18030&apos;)friends = fs_str.split(&apos;\\n&apos;)siglist = []for i in friends: if i.__len__()&gt;0: i = i.replace(&apos;&lt;ContactList: [&apos;,&apos;&quot;&lt;ContactList: [&apos;) i = i.replace(&apos;]&gt;&apos;,&apos;]&gt;&quot;&apos;) friend = eval(i) # print(friend) # print(friend[&quot;Signature&quot;]) signature = friend[&quot;Signature&quot;].strip().replace(&quot;span&quot;,&quot;&quot;).replace(&quot;class&quot;,&quot;&quot;).replace(&quot;emoji&quot;,&quot;&quot;) rep = re.compile(&quot;1f\\d+\\w*|[&lt;&gt;/=]&quot;) signature = rep.sub(&quot;&quot;,signature) siglist.append(signature)text = &quot;&quot;.join(siglist)import jiebawordlist = jieba.cut(text,cut_all=True)word_space_split = &quot; &quot;.join(wordlist).replace(&quot;\\n&quot;,&quot;&quot;)print(word_space_split)import matplotlib.pyplot as pltfrom wordcloud import WordCloud, ImageColorGeneratorimport numpy as npimport PIL.Image as Imagecoloring = np.array(Image.open(base_pic))my_wordcloud = WordCloud(background_color=&quot;white&quot;,max_words=2000, mask=coloring,max_font_size=60,random_state=42,scale=2, font_path=&quot;C:/windows/fonts/SimHei.ttf&quot;).generate(word_space_split)image_colors = ImageColorGenerator(coloring)plt.imshow(my_wordcloud.recolor(color_func=image_colors))plt.imshow(my_wordcloud)plt.axis(&quot;off&quot;)plt.show() 效果：","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"flask 应用的架构和部署(flask+gunicorn+nginx)","slug":"flask 应用的架构和部署(flask+gunicorn+nginx)","date":"2017-07-07T01:44:33.000Z","updated":"2017-08-08T06:38:51.099Z","comments":true,"path":"2017/07/07/flask 应用的架构和部署(flask+gunicorn+nginx)/","link":"","permalink":"http://yoursite.com/2017/07/07/flask 应用的架构和部署(flask+gunicorn+nginx)/","excerpt":"","text":"本文主要介绍flask+gunicorn+nginx的配合部署过程，它只是入门的部署过程，当你的web应用有并发要求时，还应加上缓存和队列调度等等，这部分可以参考https://zhuanlan.zhihu.com/p/25038203 前言： 1.为什么要使用gunicorn？目前我们使用flask内建的wsgi server，这个server由于是单进程单线程模型的，所以性能很差，一个请求不处理完的话服务器就会阻塞住其他请求，我们需要对这个server做替换。而gunicorn是一个python编写的高效的WSGI HTTP服务器，它比uwsgi使用更简单2.为什么需要nginx？nginx反向代理能带给我们很多好处： 负载均衡，把请求平均地分到上游的app server进程。 静态文件处理，静态文件的访问交给nginx来处理，降低了app server的压力。 接收完客户端所有的TCP包，再一次交给上游的应用来处理，防止app server被慢请求干扰。 访问控制和路由重写。 强大的ngx_lua模块。 Proxy cache。 Gzip，SSL… 应用架构: 部署步骤： 1. wsgi项目中创建wsgi.py1234from app import create_appapplication = create_app(&apos;production&apos;)if __name__ == &apos;__main__&apos;: application.run() 2.远程复制scp远程复制项目文件到服务器12# 在本地目录内执行scp -r app jason@10.222.32.10:/usr/share/www 3.安装各种环境和依赖包并测试gunicorn服务在服务器上执行12345678910111213# 安装venv环境virtualenv venv. venv/bin/activate# 安装依赖包pip install -r requirements.txt#安装gunicornpip install gunicorn# 测试运行服务gunicorn -w 4 -b 127.0.0.1:8000 wsgi:application# 解释-w ：要开多少个worker，即开启几个进程-b ：指定host地址wsgi: ：声明入口wsgi文件中的全局变量 4.配置upstart在linux启动时就跟随启动起来在项目中编写upstart.conf并复制到服务器命名为blog.conf12345678910111213description &quot;My Blog service&quot;# 运行级别start on runlevel [2345]stop on runlevel [!2345]# 用户id和用户组respawnsetuid rootsetgid www-data# 运行路径和服务运行时的工作目录env PATH=/usr/share/www/venv/binchdir /usr/share/www/exec gunicorn -w 4 -b 127.0.0.1:8000 wsgi:application 在服务器端123456# 建立服务目录配置sudo nano /etc/init/blog.conf# 测试建立的文件deactivate# 开启服务sudo service blog start 5. 配置nginx（反向代理）在项目中编写nginx.conf12345678910111213# /ect/nginx/sites-available/defaultserver &#123; listen 80; server_name 10.211.55.10; location / &#123; # 要和gunicorn配置的host地址对应上 proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; 在服务器端12345# 进入nginx默认配置文件sudo nano /ect/nginx/sites-available/default# 将server&#123;&#125;中的内容替换为上面写的内容# 重启nginxsudo service nginx restart 6. 初始化数据库并重启服务在服务器端12345678createdb blog-dbcd /usr/share/www. venv/bin/activatepython manage.py db upgradedeactivatesudo service blog restart","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"kuberbets","slug":"kuberbets","permalink":"http://yoursite.com/tags/kuberbets/"}]},{"title":"如何运用docker配合python开发","slug":"如何运用docker配合python开发","date":"2017-07-05T01:44:33.000Z","updated":"2017-08-09T02:15:57.545Z","comments":true,"path":"2017/07/05/如何运用docker配合python开发/","link":"","permalink":"http://yoursite.com/2017/07/05/如何运用docker配合python开发/","excerpt":"","text":"由于开发一个python程序时需要依赖大量的三方库包，且python2和3本身就有互不兼容的地方，我们往往需要一个隔离的环境，来避免版本影响造成的bug。传统的做法大多数人可能会选择virtualenv来隔离，但是它有很多明显的缺点： 无法提供完全的隔离 如果不想在正式环境中使用，它就会造成差异 而随着容器技术的日渐成熟和普及，Docker无疑成为解决这个问题的最优解本文将主要介绍docker和flask的配合开发 步骤：1.安装Docker（这里不详细介绍）12# 参考命令sudo wget -qO- https://get.docker.com/ | sh 2.应用目录结构123456789├──fanxiangce_docker ├── Dockerfile ├── Readme.md └─fanxiangce └──app ├── manage.py └── requirements ├── common.txt 3.编写Dockerfile（详细命令解释可以参考https://docs.docker.com/engine/reference/builder/#environment-replacement）12345678910111213141516171819202122232425262728293031323334353637383940########################################################## # Dockerfile to run a flask-based web application# Based on an centos:7 image ########################################################### Set the base image to use to centos FROM centos:7# Set the file maintainer MAINTAINER jasonwang,wjs7740@163.com# Set env varibles used in this Dockerfile (add a unique prefix, such as DOCKYARD) # Local directory with project source ENV DOCKYARD_SRC=fanxiangce# Directory in Container for all project files ENV DOCKYARD_SRCHOME=/opt # Directory in container for project source files ENV DOCKYARD_SRCPROJ=/opt/fanxiangce# Update the defualt application repository source list RUN yum -y install epel-release RUN yum -y install python-pip RUN yum clean all# Copy application source code to SRCDIR COPY $DOCKYARD_SRC $DOCKYARD_SRCPROJ# Create application subdirectories WORKDIR $DOCKYARD_SRCPROJ RUN mkdir log VOLUME [&apos;$DOCKYARD_SRCPROJ/log/&apos;]# Install Python dependencies RUN pip install --upgrade pipRUN pip install -r $DOCKYARD_SRCPROJ/requirements/common.txt# Port to expose EXPOSE 8000# Copy entrypoint script into the image WORKDIR $DOCKYARD_SRCPROJ 4. build镜像12# 在Dockerfile同级目录下sudo docker build -t jason/webdemo . 成功后显示Successfully，同时返回镜像ID，如图： 5.查看并启动镜像注意，此处-p映射的端口（主机端口：容器端口），容器端口应与flask应用定义的端口一致12sudo docker imagessudo docker run -it --name webdemo -p 8000:8000 jason/webdemo /bin/bash 6.在容器中启动flask应用1python manage.py runserver -p 8000 启动成功如下截图： 7.在浏览器输入127.0.0.1:8000即可访问应用 8.后续如果容器关闭后需要再次进入，可以用如下命令123456# 查看当前容器 sudo docker ps -a# 启动容器docker start webdemo# 进入容器docker attach webdemo","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"kuberbets","slug":"kuberbets","permalink":"http://yoursite.com/tags/kuberbets/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java实现将多个文件打包成zip压缩文件以及对压缩文件的加密","slug":"java实现将多个文件打包成zip压缩文件以及对压缩文件的加密 - 副本","date":"2016-01-05T01:44:33.000Z","updated":"2017-08-09T02:19:53.913Z","comments":true,"path":"2016/01/05/java实现将多个文件打包成zip压缩文件以及对压缩文件的加密 - 副本/","link":"","permalink":"http://yoursite.com/2016/01/05/java实现将多个文件打包成zip压缩文件以及对压缩文件的加密 - 副本/","excerpt":"","text":"如果仅仅需要对文件进行压缩，方法比较简单，因为java的util包中提供了相关的压缩方法.首先，引入java.util.zip.ZipEntry,java.util.zip.ZipOutputStream包然后加入以下代码：1234567891011121314151617181920String now = StringUtils.dateToString(new Date());String path = request.getServletPath();path = request.getRealPath(path);path = path.substring(0,path.lastIndexOf(&quot;\\\\&quot;))+&quot;\\\\&quot;;File zipFile = new File(path+&quot;edm_expcsv\\\\&quot;+&quot;EDM_expcsv_&quot;+now+&quot;.zip&quot;); //压缩的文件名和地址 ZipOutputStream out2 = new ZipOutputStream(new FileOutputStream(zipFile));//传入压缩文件路径，得到压缩流 byte[] buffer = new byte[1024]; File[] file1 = &#123;new File(path+file),new File(path+file2)&#125;;for(int x=0;x&lt;file1.length;x++) &#123; FileInputStream fis = new FileInputStream(file1[x]);out2.putNextEntry(new ZipEntry(file1[x].getName()));//将要压缩的文件放入压缩流 int len;//读入需要下载的文件的内容，打包到zip文件 while((len = fis.read(buffer))&gt;0) &#123; out2.write(buffer,0,len); &#125; out2.closeEntry(); fis.close();&#125;out2.close(); 如果是要对文件压缩并加密，则使用下面的方法，但是值支持单个文件压缩 先将ant.jar commons-io.jar EncryptZip.jar EncryptZip.jar winzip.1.1.0.jar文件放到lib包中 然后在头文件import中加入String,java.io.File,de.idyl.winzipaes.AesZipFileEncrypter,de.idyl.winzipaes.impl.AESEncrypterBC 然后加入代码1234567File file = newFile(s); //定义压缩文件的路径File zipFile = new File(b + &quot;\\\\demo.zip&quot;);//压缩的文件名和地址AESEncrypterBC bc = new AESEncrypterBC();AesZipFileEncrypter azfe = new AesZipFileEncrypter(zipFile, bc);azfe.setEncoding(&quot;UTF-8&quot;); // 编码格式是在这传进去的azfe.add(file,&quot;123.jpg&quot;, &quot;123&quot;); //1：要压缩的文件路径，2：为压缩的文件命名3：为密码azfe.close();","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]}