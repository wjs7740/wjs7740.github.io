{"meta":{"title":"Jason Say","subtitle":"","description":"Jason写字的地方","author":"Jason Wang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"java实现kubernates API的访问调用","slug":"java实现kubernates-API的访问调用","date":"2017-08-07T01:44:33.000Z","updated":"2017-08-09T02:12:47.685Z","comments":true,"path":"2017/08/07/java实现kubernates-API的访问调用/","link":"","permalink":"http://yoursite.com/2017/08/07/java实现kubernates-API的访问调用/","excerpt":"","text":"1. 前言kubernetes及各开源社区为开发人员提供了各种语言版的Client Library，让我们可以通过编程的方式可以实现调用Kubernetes API，从而完成pod、service、RC等资源的图形化创建和管理。本篇主要介绍使用java语言的实现 2. 使用场景开发基于kubernetes的容器云管理平台 3. 基于的框架用java语言开发的有两种，一个是基于Jersey的，一个是基于Fabric8。 -Jersey是一个方便简化开发RESRFul Web Service的框架，契合kubernetesAPI的设计，所以采用jersey会比较省力，但还是需要开发者自己做很多工作。 -Fabric8中的kubernates-client.xx.jar，kubernates-model.xx.jar等工具包包对kubernates api做了很好的封装，访问代码比较简单。 本篇将选择fabric8实现 4. 使用步骤4.1 首先导入核心jar包 4.2 创建连接API-Server的client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package org.demo.framework.engine.k8s.util;import io.fabric8.kubernetes.api.model.*;import io.fabric8.kubernetes.api.model.extensions.*;import io.fabric8.kubernetes.api.model.extensions.Deployment;import io.fabric8.kubernetes.client.Config;import io.fabric8.kubernetes.client.ConfigBuilder;import io.fabric8.kubernetes.client.*;import okhttp3.TlsVersion;import org.apache.log4j.Logger;import java.io.Closeable;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Map;public class Fabric8KubeUtils implements KubeUtils&lt;KubernetesClient&gt; &#123; private KubernetesClient client; private static final int CONNECTION_TIMEOUT = 3 * 1000; private static final int REQUEST_TIMEOUT = 3 * 1000; private static Logger logger = Logger.getLogger(Fabric8KubeUtils.class); @Override public KubernetesClient getClient() &#123; return client; &#125; @Override public void setClient(KubernetesClient client) &#123; this.client = client; &#125; private Fabric8KubeUtils(KubernetesClient client) &#123; this.client = client; &#125; /**传入参数，连接k8s的api server**/ public static KubeUtils buildKubeUtils(Cluster cluster, String namespace) throws K8sDriverException &#123; if (cluster == null) &#123; throw new K8sDriverException(&quot;cluster is null&quot;); &#125; String key = cluster.md5Key(namespace); if (KUBEUTILSMAP.containsKey(key)) &#123; return KUBEUTILSMAP.get(key); &#125; String master = cluster.getApi(); master = CommonUtil.fullUrl(master); if (StringUtils.isBlank(master)) &#123; throw new K8sDriverException(&quot;master api is null, cluster id=&quot; + cluster.getId() + &quot;, cluster name=&quot; + cluster.getName()); &#125; Config config; if (master.toLowerCase().startsWith(&quot;https://&quot;)) &#123; config = new ConfigBuilder().withMasterUrl(master) .withTrustCerts(true) .withNamespace(namespace) .withOauthToken(cluster.getOauthToken()) .withUsername(cluster.getUsername()) .withPassword(cluster.getPassword()) .removeFromTlsVersions(TlsVersion.TLS_1_0) .removeFromTlsVersions(TlsVersion.TLS_1_1) .removeFromTlsVersions(TlsVersion.TLS_1_2) .withRequestTimeout(REQUEST_TIMEOUT) .withConnectionTimeout(CONNECTION_TIMEOUT) .build(); &#125; else &#123; config = new ConfigBuilder().withMasterUrl(master) .withNamespace(namespace) .withOauthToken(cluster.getOauthToken()) .withUsername(cluster.getUsername()) .withPassword(cluster.getPassword()) .removeFromTlsVersions(TlsVersion.TLS_1_0) .removeFromTlsVersions(TlsVersion.TLS_1_1) .removeFromTlsVersions(TlsVersion.TLS_1_2) .withTrustCerts(true) .withRequestTimeout(REQUEST_TIMEOUT) .withConnectionTimeout(CONNECTION_TIMEOUT) .build(); &#125; KubeUtils kubeUtils = buildKubeUtils(config); KUBEUTILSMAP.putIfAbsent(key, kubeUtils); return kubeUtils; &#125; /**创建client**/ public static KubeUtils buildKubeUtils(Config config) throws K8sDriverException &#123; KubernetesClient client; try &#123; client = new DefaultKubernetesClient(config); &#125; catch (Exception e) &#123; throw new K8sDriverException(&quot;instantialize kubernetes client error&quot;); &#125; return new Fabric8KubeUtils(client); &#125; &#125; 4.3 创建k8s的资源对象，作为参传给client操作k8s（增删改时需要）123// 可以通过k8s??Builder()来创建资源对象// 如下创建一个service对象，lb为包含service必要信息的实体类对象Service newService = new K8sServiceBuilder(lb).build(); 4.4 通过得到的client，可以对k8s的各种资源增删改查各种操作：NodesNamespacesServicesReplicationcontrollersPodsDeploymentsResourcequotas1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/**创建pod**/@Override public Pod createPod(Pod pod) throws K8sDriverException &#123; logger.debug(&quot;create pod with specify=&quot; + pod.toString()); try &#123; return client.pods().create(pod); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;/**创建service**/@Overridepublic Service createService(Service service) throws K8sDriverException &#123; logger.debug(&quot;create service=&quot; + service); if (service == null) &#123; return null; &#125; try &#123; return client.services().create(service); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125;&#125;/**创建RC**/ @Override public ReplicationController createReplicationController(ReplicationController rc) throws K8sDriverException &#123; if (rc == null) &#123; return null; &#125; logger.debug(&quot;create replication controller with rc=\\n&quot; + rc); try &#123; return client.replicationControllers().create(rc); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;/**创建deployment**/@Override public Deployment createDeployment(Deployment deployment) throws K8sDriverException &#123; if (deployment == null) &#123; return null; &#125; logger.debug(&quot;create deployment with deployment=\\n&quot; + deployment); try &#123; return client.extensions().deployments().create(deployment); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;/**按条件列出所有node**/@Override public NodeList listNode(Map&lt;String, String&gt; labelSelector) throws K8sDriverException &#123; logger.debug(&quot;list node with selector=&quot; + labelSelector); try &#123; return client.nodes().withLabels(labelSelector).list(); &#125; catch (KubernetesClientException e) &#123; throw new K8sDriverException(e.getMessage()); &#125; &#125;","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"kuberbets","slug":"kuberbets","permalink":"http://yoursite.com/tags/kuberbets/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"用python 分析微信好友信息并生成词云","slug":"用python 分析微信好友信息并生成词云","date":"2017-08-07T01:24:33.000Z","updated":"2017-08-07T01:50:17.806Z","comments":true,"path":"2017/08/07/用python 分析微信好友信息并生成词云/","link":"","permalink":"http://yoursite.com/2017/08/07/用python 分析微信好友信息并生成词云/","excerpt":"","text":"在知乎上偶然看到有人推荐itchart这个微信接口，抱着好奇的想法尝试了以下，果然非常好玩。官方链接：http://itchat.readthedocs.io/zh/latest/#itchat 目录结构get_info.py这个类用来爬取好友信息并保存到指定文件12345678910111213141516171819202122232425import itchatimport osimport timebasepath = os.path.dirname(os.path.realpath(__file__))download_path = basepath+&apos;\\downloads&apos;+ &apos;\\\\&apos;# 调用itchat接口登录并拉取数据itchat.login()friends = itchat.get_friends(update=True)[0:]fmt=&apos;%Y%m%d%H%M%S&apos; #定义时间显示格式Date=time.strftime(fmt,time.localtime(time.time()))download_file_name = &apos;friendslist_&apos;+friends[0][&apos;NickName&apos;]+ &apos;_&apos; + Date + &apos;.txt&apos;f = open(download_path+download_file_name,&apos;wb&apos;)print(download_path+download_file_name)for i in friends[1:]: friend = (str(i) + &quot;\\n&quot;).encode(encoding=&apos;gb18030&apos;) # print(str(i)) f.write(friend)f.close() analyse.py这个类根据下载的好友数据分析好友信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Author:Jason.wangimport reimport osimport timebase_pic = &quot;C:/Users/Think/Pictures/Saved Pictures/beb28c538ac52a91.jpg&quot;source_file = &quot;friendslist_雨佳Clara_20170724223344.txt&quot;source_file = &quot;friendslist_say_20170724132202.txt&quot;basepath = os.path.dirname(os.path.realpath(__file__))download_file = basepath+&apos;\\downloads\\\\&apos;+ source_filefs_str = &apos;&apos;with open(download_file,&apos;rb&apos;) as f: fs_str = f.read().decode(&apos;gb18030&apos;)friends = fs_str.split(&apos;\\n&apos;)# 初始化计数器 male = female = other = 0# 所有省份Provinces_list = []#friends[0]是自己的信息，所以要从friends[1]开始 for i in friends: if i.__len__()&gt;0: i = i.replace(&apos;&lt;ContactList: [&apos;,&apos;&quot;&lt;ContactList: [&apos;) i = i.replace(&apos;]&gt;&apos;,&apos;]&gt;&quot;&apos;) friend = eval(i) # 统计性别 sex = friend[&quot;Sex&quot;] if sex == 1: male += 1 exit elif sex ==2: female += 1 else: other+=1 # 统计地区 Province = friend[&quot;Province&quot;] Provinces_list.append(Province)#计算朋友总数 total = len(friends)#打印出自己的好友性别比例 print(&quot;总好友数： %d&quot; % total + &quot;\\n&quot; + &quot;男性好友： %d 个,占比 %.2f%%&quot; % (male,(float(male)/total*100)) + &quot;\\n&quot; + &quot;女性好友： %d 个,占比 %.2f%%&quot; % (female,(float(female) / total * 100)) + &quot;\\n&quot; + &quot;不明性别好友： %d 个,占比 %.2f%%&quot; % (other,(float(other) / total * 100)))Provinces_set = set(Provinces_list)Provinces_dict = &#123;&#125;for i in Provinces_set: Provinces_dict[i] = Provinces_list.count(i)# 对省份字典按value排序Provinces_dict = sorted(Provinces_dict.items(),key=lambda asd:asd[1],reverse=True)print(&quot;===============人数排名前10地区如下==================&quot;)top = 0for k,v in Provinces_dict: if top&lt;10: print(&quot;%s : %d 个，占比 ： %.2f%%&quot; % (k,v,float(v)/total*100)) top+=1 输出结果： ciyun.py根据签名生成词云123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*- coding:UTF-8 -*-# Author:Jason.wangimport reimport osimport timebase_pic = &quot;C:/Users/Think/Pictures/Saved Pictures/beb28c538ac52a91.jpg&quot;source_file = &quot;friendslist_雨佳Clara_20170724223344.txt&quot;# source_file = &quot;friendslist_say_20170724132202.txt&quot;basepath = os.path.dirname(os.path.realpath(__file__))download_file = basepath+&apos;\\downloads\\\\&apos;+ source_filefs_str = &apos;&apos;with open(download_file,&apos;rb&apos;) as f: fs_str = f.read().decode(&apos;gb18030&apos;)friends = fs_str.split(&apos;\\n&apos;)siglist = []for i in friends: if i.__len__()&gt;0: i = i.replace(&apos;&lt;ContactList: [&apos;,&apos;&quot;&lt;ContactList: [&apos;) i = i.replace(&apos;]&gt;&apos;,&apos;]&gt;&quot;&apos;) friend = eval(i) # print(friend) # print(friend[&quot;Signature&quot;]) signature = friend[&quot;Signature&quot;].strip().replace(&quot;span&quot;,&quot;&quot;).replace(&quot;class&quot;,&quot;&quot;).replace(&quot;emoji&quot;,&quot;&quot;) rep = re.compile(&quot;1f\\d+\\w*|[&lt;&gt;/=]&quot;) signature = rep.sub(&quot;&quot;,signature) siglist.append(signature)text = &quot;&quot;.join(siglist)import jiebawordlist = jieba.cut(text,cut_all=True)word_space_split = &quot; &quot;.join(wordlist).replace(&quot;\\n&quot;,&quot;&quot;)print(word_space_split)import matplotlib.pyplot as pltfrom wordcloud import WordCloud, ImageColorGeneratorimport numpy as npimport PIL.Image as Imagecoloring = np.array(Image.open(base_pic))my_wordcloud = WordCloud(background_color=&quot;white&quot;,max_words=2000, mask=coloring,max_font_size=60,random_state=42,scale=2, font_path=&quot;C:/windows/fonts/SimHei.ttf&quot;).generate(word_space_split)image_colors = ImageColorGenerator(coloring)plt.imshow(my_wordcloud.recolor(color_func=image_colors))plt.imshow(my_wordcloud)plt.axis(&quot;off&quot;)plt.show() 效果：","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"flask 应用的架构和部署(flask+gunicorn+nginx)","slug":"flask 应用的架构和部署(flask+gunicorn+nginx)","date":"2017-07-07T01:44:33.000Z","updated":"2017-08-08T06:38:51.099Z","comments":true,"path":"2017/07/07/flask 应用的架构和部署(flask+gunicorn+nginx)/","link":"","permalink":"http://yoursite.com/2017/07/07/flask 应用的架构和部署(flask+gunicorn+nginx)/","excerpt":"","text":"本文主要介绍flask+gunicorn+nginx的配合部署过程，它只是入门的部署过程，当你的web应用有并发要求时，还应加上缓存和队列调度等等，这部分可以参考https://zhuanlan.zhihu.com/p/25038203 前言： 1.为什么要使用gunicorn？目前我们使用flask内建的wsgi server，这个server由于是单进程单线程模型的，所以性能很差，一个请求不处理完的话服务器就会阻塞住其他请求，我们需要对这个server做替换。而gunicorn是一个python编写的高效的WSGI HTTP服务器，它比uwsgi使用更简单2.为什么需要nginx？nginx反向代理能带给我们很多好处： 负载均衡，把请求平均地分到上游的app server进程。 静态文件处理，静态文件的访问交给nginx来处理，降低了app server的压力。 接收完客户端所有的TCP包，再一次交给上游的应用来处理，防止app server被慢请求干扰。 访问控制和路由重写。 强大的ngx_lua模块。 Proxy cache。 Gzip，SSL… 应用架构: 部署步骤： 1. wsgi项目中创建wsgi.py1234from app import create_appapplication = create_app(&apos;production&apos;)if __name__ == &apos;__main__&apos;: application.run() 2.远程复制scp远程复制项目文件到服务器12# 在本地目录内执行scp -r app jason@10.222.32.10:/usr/share/www 3.安装各种环境和依赖包并测试gunicorn服务在服务器上执行12345678910111213# 安装venv环境virtualenv venv. venv/bin/activate# 安装依赖包pip install -r requirements.txt#安装gunicornpip install gunicorn# 测试运行服务gunicorn -w 4 -b 127.0.0.1:8000 wsgi:application# 解释-w ：要开多少个worker，即开启几个进程-b ：指定host地址wsgi: ：声明入口wsgi文件中的全局变量 4.配置upstart在linux启动时就跟随启动起来在项目中编写upstart.conf并复制到服务器命名为blog.conf12345678910111213description &quot;My Blog service&quot;# 运行级别start on runlevel [2345]stop on runlevel [!2345]# 用户id和用户组respawnsetuid rootsetgid www-data# 运行路径和服务运行时的工作目录env PATH=/usr/share/www/venv/binchdir /usr/share/www/exec gunicorn -w 4 -b 127.0.0.1:8000 wsgi:application 在服务器端123456# 建立服务目录配置sudo nano /etc/init/blog.conf# 测试建立的文件deactivate# 开启服务sudo service blog start 5. 配置nginx（反向代理）在项目中编写nginx.conf12345678910111213# /ect/nginx/sites-available/defaultserver &#123; listen 80; server_name 10.211.55.10; location / &#123; # 要和gunicorn配置的host地址对应上 proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; 在服务器端12345# 进入nginx默认配置文件sudo nano /ect/nginx/sites-available/default# 将server&#123;&#125;中的内容替换为上面写的内容# 重启nginxsudo service nginx restart 6. 初始化数据库并重启服务在服务器端12345678createdb blog-dbcd /usr/share/www. venv/bin/activatepython manage.py db upgradedeactivatesudo service blog restart","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"kuberbets","slug":"kuberbets","permalink":"http://yoursite.com/tags/kuberbets/"}]},{"title":"如何运用docker配合python开发","slug":"如何运用docker配合python开发","date":"2017-07-05T01:44:33.000Z","updated":"2017-08-09T02:15:57.545Z","comments":true,"path":"2017/07/05/如何运用docker配合python开发/","link":"","permalink":"http://yoursite.com/2017/07/05/如何运用docker配合python开发/","excerpt":"","text":"由于开发一个python程序时需要依赖大量的三方库包，且python2和3本身就有互不兼容的地方，我们往往需要一个隔离的环境，来避免版本影响造成的bug。传统的做法大多数人可能会选择virtualenv来隔离，但是它有很多明显的缺点： 无法提供完全的隔离 如果不想在正式环境中使用，它就会造成差异 而随着容器技术的日渐成熟和普及，Docker无疑成为解决这个问题的最优解本文将主要介绍docker和flask的配合开发 步骤：1.安装Docker（这里不详细介绍）12# 参考命令sudo wget -qO- https://get.docker.com/ | sh 2.应用目录结构123456789├──fanxiangce_docker ├── Dockerfile ├── Readme.md └─fanxiangce └──app ├── manage.py └── requirements ├── common.txt 3.编写Dockerfile（详细命令解释可以参考https://docs.docker.com/engine/reference/builder/#environment-replacement）12345678910111213141516171819202122232425262728293031323334353637383940########################################################## # Dockerfile to run a flask-based web application# Based on an centos:7 image ########################################################### Set the base image to use to centos FROM centos:7# Set the file maintainer MAINTAINER jasonwang,wjs7740@163.com# Set env varibles used in this Dockerfile (add a unique prefix, such as DOCKYARD) # Local directory with project source ENV DOCKYARD_SRC=fanxiangce# Directory in Container for all project files ENV DOCKYARD_SRCHOME=/opt # Directory in container for project source files ENV DOCKYARD_SRCPROJ=/opt/fanxiangce# Update the defualt application repository source list RUN yum -y install epel-release RUN yum -y install python-pip RUN yum clean all# Copy application source code to SRCDIR COPY $DOCKYARD_SRC $DOCKYARD_SRCPROJ# Create application subdirectories WORKDIR $DOCKYARD_SRCPROJ RUN mkdir log VOLUME [&apos;$DOCKYARD_SRCPROJ/log/&apos;]# Install Python dependencies RUN pip install --upgrade pipRUN pip install -r $DOCKYARD_SRCPROJ/requirements/common.txt# Port to expose EXPOSE 8000# Copy entrypoint script into the image WORKDIR $DOCKYARD_SRCPROJ 4. build镜像12# 在Dockerfile同级目录下sudo docker build -t jason/webdemo . 成功后显示Successfully，同时返回镜像ID，如图： 5.查看并启动镜像注意，此处-p映射的端口（主机端口：容器端口），容器端口应与flask应用定义的端口一致12sudo docker imagessudo docker run -it --name webdemo -p 8000:8000 jason/webdemo /bin/bash 6.在容器中启动flask应用1python manage.py runserver -p 8000 启动成功如下截图： 7.在浏览器输入127.0.0.1:8000即可访问应用 8.后续如果容器关闭后需要再次进入，可以用如下命令123456# 查看当前容器 sudo docker ps -a# 启动容器docker start webdemo# 进入容器docker attach webdemo","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"kuberbets","slug":"kuberbets","permalink":"http://yoursite.com/tags/kuberbets/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java实现将多个文件打包成zip压缩文件以及对压缩文件的加密","slug":"java实现将多个文件打包成zip压缩文件以及对压缩文件的加密","date":"2016-01-05T01:44:33.000Z","updated":"2017-08-09T02:19:53.913Z","comments":true,"path":"2016/01/05/java实现将多个文件打包成zip压缩文件以及对压缩文件的加密/","link":"","permalink":"http://yoursite.com/2016/01/05/java实现将多个文件打包成zip压缩文件以及对压缩文件的加密/","excerpt":"","text":"如果仅仅需要对文件进行压缩，方法比较简单，因为java的util包中提供了相关的压缩方法.首先，引入java.util.zip.ZipEntry,java.util.zip.ZipOutputStream包然后加入以下代码：1234567891011121314151617181920String now = StringUtils.dateToString(new Date());String path = request.getServletPath();path = request.getRealPath(path);path = path.substring(0,path.lastIndexOf(&quot;\\\\&quot;))+&quot;\\\\&quot;;File zipFile = new File(path+&quot;edm_expcsv\\\\&quot;+&quot;EDM_expcsv_&quot;+now+&quot;.zip&quot;); //压缩的文件名和地址 ZipOutputStream out2 = new ZipOutputStream(new FileOutputStream(zipFile));//传入压缩文件路径，得到压缩流 byte[] buffer = new byte[1024]; File[] file1 = &#123;new File(path+file),new File(path+file2)&#125;;for(int x=0;x&lt;file1.length;x++) &#123; FileInputStream fis = new FileInputStream(file1[x]);out2.putNextEntry(new ZipEntry(file1[x].getName()));//将要压缩的文件放入压缩流 int len;//读入需要下载的文件的内容，打包到zip文件 while((len = fis.read(buffer))&gt;0) &#123; out2.write(buffer,0,len); &#125; out2.closeEntry(); fis.close();&#125;out2.close(); 如果是要对文件压缩并加密，则使用下面的方法，但是值支持单个文件压缩 先将ant.jar commons-io.jar EncryptZip.jar EncryptZip.jar winzip.1.1.0.jar文件放到lib包中 然后在头文件import中加入String,java.io.File,de.idyl.winzipaes.AesZipFileEncrypter,de.idyl.winzipaes.impl.AESEncrypterBC 然后加入代码1234567File file = newFile(s); //定义压缩文件的路径File zipFile = new File(b + &quot;\\\\demo.zip&quot;);//压缩的文件名和地址AESEncrypterBC bc = new AESEncrypterBC();AesZipFileEncrypter azfe = new AesZipFileEncrypter(zipFile, bc);azfe.setEncoding(&quot;UTF-8&quot;); // 编码格式是在这传进去的azfe.add(file,&quot;123.jpg&quot;, &quot;123&quot;); //1：要压缩的文件路径，2：为压缩的文件命名3：为密码azfe.close();","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]}